Optimization Monte Carlo: Efficient and Embarrassingly Parallel Likelihood-Free Inference

Edward Meeds Informatics Institute University of Amsterdam tmeeds@gmail.com

Max Welling Informatics Institute University of Amsterdam welling.max@gmail.com

Abstract
We describe an embarrassingly parallel, anytime Monte Carlo method for likelihood-free models. The algorithm starts with the view that the stochasticity of the pseudo-samples generated by the simulator can be controlled externally by a vector of random numbers u, in such a way that the outcome, knowing u, is deterministic. For each instantiation of u we run an optimization procedure to minimize the distance between summary statistics of the simulator and the data. After reweighing these samples using the prior and the Jacobian (accounting for the change of volume in transforming from the space of summary statistics to the space of parameters) we show that this weighted ensemble represents a Monte Carlo estimate of the posterior distribution. The procedure can be run embarrassingly parallel (each node handling one sample) and anytime (by allocating resources to the worst performing sample). The procedure is validated on six experiments.
1 Introduction
Computationally demanding simulators are used across the full spectrum of scientific and industrial applications, whether one studies embryonic morphogenesis in biology, tumor growth in cancer research, colliding galaxies in astronomy, weather forecasting in meteorology, climate changes in the environmental science, earthquakes in seismology, market movement in economics, turbulence in physics, brain functioning in neuroscience, or fabrication processes in industry. Approximate Bayesian computation (ABC) forms a large class algorithms that aims to sample from the posterior distribution over parameters for these likelihood-free (a.k.a. simulator based) models. Likelihoodfree inference, however, is notoriously inefficient in terms of the number of simulation calls per independent sample. Further, like regular Bayesian inference algorithms, care must be taken so that posterior sampling targets the correct distribution.
The simplest ABC algorithm, ABC rejection sampling, can be fully parallelized by running independent processes with no communication or synchronization requirements. I.e. it is an embarrassingly parallel algorithm. Unfortunately, as the most inefficient ABC algorithm, the benefits of this title are limited. There has been considerable progress in distributed MCMC algorithms aimed at large-scale data problems [2, 1]. Recently, a sequential Monte Carlo (SMC) algorithm called "the particle cascade" was introduced that emits streams of samples asynchronously with minimal memory management and communication [17]. In this paper we present an alternative embarrassingly parallel sampling approach: each processor works independently, at full capacity, and will indefinitely emit independent samples. The main trick is to pull random number generation outside of the simulator and treat the simulator as a deterministic piece of code. We then minimize the difference
Donald Bren School of Information and Computer Sciences University of California, Irvine, and Canadian Institute for Advanced Research.
1

between observations and the simulator output over its input parameters and weight the final (optimized) parameter value with the prior and the (inverse of the) Jacobian. We show that the resulting weighted ensemble represents a Monte Carlo estimate of the posterior. Moreover, we argue that the error of this procedure is O( ) if the optimization gets -close to the optimal value. This "Optimization Monte Carlo" (OMC) has several advantages: 1) it can be run embarrassingly parallel, 2) the procedure generates independent samples and 3) the core procedure is now optimization rather than MCMC. Indeed, optimization as part of a likelihood-free inference procedure has recently been proposed [12]; using a probabilistic model of the mapping from parameters to differences between observations and simulator outputs, they apply "Bayesian Optimization" (e.g. [13, 21]) to efficiently perform posterior inference. Note also that since random numbers have been separated out from the simulator, powerful tools such as "automatic differentiation" (e.g. [14]) are within reach to assist with the optimization. In practice we find that OMC uses far fewer simulations per sample than alternative ABC algorithms.
The approach of controlling randomness as part of an inference procedure is also found in a related class of parameter estimation algorithms called indirect inference [11]. Connections between ABC and indirect inference have been made previously by [7] as a novel way of creating summary statistics. An indirect inference perspective led to an independently developed version of OMC called the "reverse sampler" [9, 10].
In Section 2 we briefly introduce ABC and present it from a novel viewpoint in terms of random numbers. In Section 3 we derive ABC through optimization from a geometric point of view, then proceed to generalize it to higher dimensions. We show in Section 4 extensive evidence of the correctness and efficiency of our approach. In Section 5 we describe the outlook for optimizationbased ABC.

2 ABC Sampling Algorithms

The primary interest in ABC is the posterior of simulator parameters  given a vector of (statistics of) observations y, p(|y). The likelihood p(y|) is generally not available in ABC. Instead we can use the simulator as a generator of pseudo-samples x that reside in the same space as y. By treating x as auxiliary variables, we can continue with the Bayesian treatment:

p(|y) = p()p(y|)  p() p (y|x)p(x|) dx p(y) p() p (y|x)p(x|) dx d

(1)

Of particular importance is the choice of kernel measuring the discrepancy between observations y and pseudo-data x. Popular choices for kernels are the Gaussian kernel and the uniform -tube/ball. The bandwidth parameter (which may be a vector accounting for relative importance of each statistic) plays critical role: small produces more accurate posteriors, but is more computationally demanding, whereas large induces larger error but is cheaper.

We focus our attention on population-based ABC samplers, which include rejection sampling, im-
portance sampling (IS), sequential Monte Carlo (SMC) [6, 20] and population Monte Carlo [3]. In rejection sampling, we draw parameters from the prior   p(), then run a simulation at those parameters x  p(x|); if the discrepancy (x, y) < , then the particle is accepted, otherwise it is rejected. This is repeated until n particles are accepted. Importance sampling generalizes rejection sampling using a proposal distribution q() instead of the prior, and produces samples with weights wi  p()/q(). SMC extends IS to multiple rounds with decreasing , adapting their particles after each round, such that each new population improves the approximation to the posterior. Our algorithm has similar qualities to SMC since we generate a population of n weighted particles,
but differs significantly since our particles are produced by independent optimization procedures,
making it completely parallel.

3 A Parallel and Efficient ABC Sampling Algorithm
Inherent in our assumptions about the simulator is that internally there are calls to a random number generator which produces the stochasticity of the pseudo-samples. We will assume for the moment that this can be represented by a vector of uniform random numbers u which, if known, would make the simulator deterministic. More concretely, we assume that any simulation output x can be represented as a deterministic function of parameters  and a vector of random numbers u,

2

(a) D = Dy

(b) D < Dy

Figure 1: Illustration of OMC geometry. (a) Dashed lines indicate contours f (, u) over  for several u. For three values of u, their initial and optimal  positions are shown (solid blue/white circles). Within the grey
acceptance region, the Jacobian, indicated by the blue diagonal line, describes the relative change in volume induced in f (, u) from a small change in . Corresponding weights  1/|J| are shown as vertical stems. (b) When D < Dy, here 1 < 2, the change in volume is proportional to the length of the line segment inside the ellipsoid (|JT J|1/2). The orange line indicates the projection of the observation onto the contour of f (, u) (in
this case, identical to the optimal).

i.e. x = f (, u). This assumption has been used previously in ABC, first in "coupled ABC" [16] and also in an application of Hamiltonian dynamics to ABC [15]. We do not make any further assumptions regarding u or p(u), though for some problems their dimension and distribution may be known a priori. In these cases it may be worth employing Sobol or other low-discrepancy sequences to further improve the accuracy of any Monte Carlo estimates.
We will first derive a dual representation for the ABC likelihood function p (y|) (see also [16]),

p (y|) = p (y|x)p(x|) dx =

p (y|x)I[x = f (, u)]p(u) dxdu

(2)

= p (y|f (, u))p(u) du

(3)

leading to the following Monte Carlo approximation of the ABC posterior,

1

p (|y)  p() p(u)p (y|f (u, )) du  n

p (y|f (ui, ))p()

i

ui  p(u)

(4)

Since p is a kernel that only accepts arguments y and f (ui, ) that are close to each other (for values of that are as small as possible), Equation 4 tells us that we should first sample values for u from p(u) and then for each such sample find the value for io that results in y = f (io, u). In practice we want to drive these values as close to each other as possible through optimization and accept an O( ) error if the remaining distance is still O( ). Note that apart from sampling the values
for u this procedure is deterministic and can be executed completely in parallel, i.e. without any
communication. In the following we will assume a single observation vector y, but the approach is
equally applicable to a dataset of N cases.

3.1 The case D = Dy
We will first study the case when the number of parameters  is equal to the number of summary statistics y. To understand the derivation it helps to look at Figure 1a which illustrates the derivation for the one dimensional case. In the following we use the following abbreviation: fi() stands for f (, ui). The general idea is that we want to write the approximation to the posterior as a mixture of small uniform balls (or delta peaks in the limit):

p(|y)  1 n

p

(y|f (ui, ))p()



1 n

wiU (|i)p()

ii

(5)

3

with wi some weights that we will derive shortly. Then, if we make small enough we can replace any average of a sufficiently smooth function h() w.r.t. this approximate posterior simply by eval-
uating h() at some arbitrarily chosen points inside these balls (for instance we can take the center of the ball i),

h()p(|y) d  1 n

h(i)wip(i)

i

(6)

To derive this expression we first assume that:

p (y|fi()) = C( )I[||y - fi()||2  2]

(7)

i.e. a ball of radius . C( ) is the normalizer which is immaterial because it cancels in the posterior. For small enough we claim that we can linearize fi() around io:

fi() = fi(io) + Joi ( - io) + Ri,

Ri = O(|| - io||2)

(8)

where

Joi

is

the

Jacobian

matrix

with

columns

. fi (io )
d

We take io to be the end result of our

optimization procedure for sample ui. Using this we thus get,

||y - fi()||2  ||(y - fi(io)) - Joi ( - io) - Ri||2

(9)

We first note that since we assume that our optimization has ended up somewhere inside the ball defined by ||y - fi()||2  2 we can assume that ||y - fi(io)|| = O( ). Also, since we only consider values for  that satisfy ||y - fi()||2  2, and furthermore assume that the function fi() is Lipschitz continuous in  it follows that || - io|| = O( ) as well. All of this implies that we can safely ignore the remaining term Ri (which is of order O(|| - io||2) = O( 2)) if we restrict ourselves to the volume inside the ball.

The next step is to view the term I[||y - fi()||2  2] as a distribution in . With the Taylor expansion this results in,

I[( - io - Joi ,-1(y - fi(io)))T Joi T Joi ( - io - Joi ,-1(y - fi(io)))  2]

This represents an ellipse in -space with a centroid i and volume Vi given by

i = io + Jio,-1(y - fi(io))

Vi =

 det(Joi T Joi )

(10) (11)

with  a constant independent of i. We can approximate the posterior now as,

p(|y)  1

U (|i)p()  1

( - i)p(i)


i

det(Joi T Joi )


i

det(Joi T Joi )

(12)

where in the last step we have send  0. Finally, we can compute the constant  through normalization,  = i p(i) det(Joi T Joi )-1/2. The whole procedure is accurate up to errors of the order O( 2), and it is assumed that the optimization procedure delivers a solution that is located within the epsilon ball. If one of the optimizations for a certain sample ui did not end up within the epsilon ball there can be two reasons: 1) the optimization did not converge to the optimal value for , or 2) for this value of u there is no solution for which f (|u) can get within a distance from the observation y. If we interpret as our uncertainty in the observation y, and we assume that our optimization succeeded in finding the best possible value for , then we should simply reject this sample i. However, it is hard to detect if our optimization succeeded and we may therefore sometimes reject samples that should not have been rejected. Thus, one should be careful not to create a bias against samples ui for which the optimization is difficult. This situation is similar to a sampler that will not mix to remote local optima in the posterior distribution.

3.2 The case D < Dy
This is the overdetermined case and here the situation as depicted in Figure 1b is typical: the manifold that f (, ui) traces out as we vary  forms a lower dimensional surface in the Dy dimensional enveloping space. This manifold may or may not intersect with the sphere centered at the observation y (or ellipsoid, for the general case instead of ). Assume that the manifold does intersect the

4

epsilon ball but not y. Since we trust our observation up to distance , we may simple choose to

pick the closest point i to y on the manifold, which is given by,

i = io + Joi (y - fi(io))

Joi  = (Joi T Joi )-1Joi T

(13)

where center

Joi  is of the

the ball

pseudo-inverse. We can from y to fi(i) (which

now define our do not coincide

ellipse around this point, in this case). The uniform

shifting the distribution

on the ellipse in -space is now defined in the D dimensional manifold and has volume Vi =

 det(Joi T Joi )-1/2. So once again we arrive at almost the same equation as before (Eq. 12) but with

the slightly different definition of the point i given by Eq. 13. Crucially, since ||y - fi(i)||  2

and if we assume that our optimization succeeded, we will only make mistakes of order O( 2).

3.3 The case D > Dy
This is the underdetermined case in which it is typical that entire manifolds (e.g. hyperplanes) may be a solution to ||y - fi(i)|| = 0. In this case we can not approximate the posterior with a mixture of point masses and thus the procedure does not apply. However, the case D > Dy is less interesting than the other ones above as we expect to have more summary statistics than parameters for most problems.

4 Experiments
The goal of these experiments is to demonstrate 1) the correctness of OMC and 2) the relative efficiency of OMC in relation to two sequential MC algorithms, SMC (aka population MC [3]) and adaptive weighted SMC [5]. To demonstrate correctness, we show histograms of weighted samples along with the true posterior (when known) and, for three experiments, the exact OMC weighted samples (when the exact Jacobian and optimal  is known). To demonstrate efficiency, we compute the mean simulations per sample (SS)--the number of simulations required to reach an threshold-- and the effective sample size (ESS), defined as 1/wT w. Additionally, we may measure ESS/n, the fraction of effective samples in the population. ESS is a good way of detecting whether the posterior is dominated by a few particles and/or how many particles achieve discrepancy less than epsilon.
There are several algorithmic options for OMC. The most obvious is to spawn independent processes, draw u for each, and optimize until is reached (or a max nbr of simulations run), then compute Jacobians and particle weights. Variations could include keeping a sorted list of discrepancies and allocating computational resources to the worst particle. However, to compare OMC with SMC, in this paper we use a sequential version of OMC that mimics the epsilon rounds of SMC. Each simulator uses different optimization procedures, including Newton's method for smooth simulators, and random walk optimization for others; Jacobians were computed using one-sided finite differences. To limit computational expense we placed a max of 1000 simulations per sample per round for all algorithms. Unless otherwise noted, we used n = 5000 and repeated runs 5 times; lack of error bars indicate very low deviations across runs. We also break some of the notational convention used thus far so that we can specify exactly how the random numbers translate into pseudo-data and the pseudo-data into statistics. This is clarified for each example. Results are explained in Figures 2 to 4.
4.1 Normal with Unknown Mean and Known Variance

The simplest example is the inference of the mean  of a univariate normal distribution with known variance 2. The prior distribution () is normal with mean 0 and variance k2, where k > 0 is

a factor relating the dispersions of  and the data yn. The simulator can generate data according to

the normal distribution, or deterministically if the random effects rum are known:

where rum the average

 = 2 s(x) =

erf
1
M

(xm|) = N (xm|, 2) = xm =  + rum
-1(2um - 1) (using the inverse CDF). A sufficient statistic for this m xm. Therefore we have f (, u) =  + R(u) where R(u) =

(14)
problem is rum /M

(the average of the random effects). In our experiment we set M = 2 and y = 0. The exact

Jacobian and io can be computed for this problem: for a draw ui, Ji = 1; if s(y) is the mean of the observations y, then by setting f (io, ui) = s(y) we find io = s(y) - R(ui). Therefore the exact weights are wi  (io), allowing us to compare directly with an exact posterior based on our dual representation by u (shown by orange circles in Figure 2 top-left). We used Newton's method to

optimize each particle.

5

Figure 2: Left: Inference of unknown mean. For 0.1, OMC uses 3.7 SS; AW/SMC uses 20/20 SS; at 0.01, OMC uses 4 SS (only 0.3 SS more), and SMC jumps to 110 SS. For all algorithms and values, ESS/n=1. Right: Inference for mixture of normals. Similar results for OMC; at 0.025 AW/SMC had 40/50 SS and at
0.01 has 105/120 SS. The ESS/n remained at 1 for OMC, but decreased to 0.06/0.47 (AW/SMC) at 0.025, and 0.35 for both at 0.01. Not only does the ESS remain high for OMC, but it also represents the tails of the distribution well, even at low .

4.2 Normal Mixture

A standard illustrative ABC problem is the inference of the mean  of a mixture of two normals

[19, 3, 5]: p(x|) =  N (, 12) + (1 - ) N (, 22), with () = U (a, b) where hyperparameters are  = 1/2, 12 = 1, 22 = 1/100, a = -10, b = 10, and a single observation scalar y = 0. For this problem M = 1 so we drop the subscript m. The true posterior is simply p(|y = 0) 

 N (, 12) + (1 - ) N (, 22),   {-10, 10}. In this problem there are two random numbers u1

and u2, one for selecting the mixture component and the other for the random innovation; further,

the statistic is the identity, i.e. s(x) = x:



x

= =

[u1 +

< ]( 
2 erf

+ 1 (2u2

-

2 erf(2u2 - 1)) + 1)1[u1<]2[u1]

[u1 =

 +

]( + R(u)

2

2 erf(2u2 - 1))

(15) (16)

where R(u)

=

 2

erf (2u2

-

1)1[u1<]2[u1].

As

with

the previous

example,

the Jacobian

is

1

and io = y - R(ui) is known exactly. This problem is notable for causing performance issues in

ABC-MCMC [19] and its difficulty in targeting the tails of the posterior [3]; this is not the case for

OMC.

4.3 Exponential with Unknown Rate

In this example, the goal is to infer the rate  of an exponential distribution, with a gamma prior p() = Gamma(|, ), based on M draws from Exp():

p(xm|) = Exp(xm|) =  exp(-xm)

=

xm

=

-1 

ln(1

-

um)

=

1  rum

(17)

where rum = - ln(1 - um) (the inverse CDF of the exponential). A sufficient statistic for this
problem is the average s(x) = m xm/M . Again, we have exact expressions for the Jacobian and io, using f (, ui) = R(ui)/, Ji = -R(ui)/2 and io = R(ui)/s(y). We used M = 2, s(y) = 10 in our experiments.

4.4 Linked Mean and Variance of Normal

In this example we link together the mean and variance of the data generating function as follows:



p(xm|) = N (xm|, 2) = xm =  +  2 erf-1(2um - 1) = rum

(18)

6

Figure 3: Left: Inference of rate of exponential. A similar result wrt SS occurs for this experiment: at 1, OMC had 15 v 45/50 for AW/SMC; at 0.01, SS was 28 OMC v 220 AW/SMC. ESS/n dropping with below 1: OMC drops at 1 to 0.71 v 0.97 for SMC; at 0.1 ESS/n remains the same. Right: Inference of linked normal. ESS/n drops significantly for OMC: at 0.25 to 0.32 and at 0.1 to 0.13, while it remains high for SMC (0.91 to 0.83). This is the result the inability of every ui to achieve  < , whereas for SMC, the algorithm allows them to "drop" their random numbers and effectively switch to another. This was verified by running an expensive fine-grained optimization, resulting in 32.9% and 13.6% optimized particles having  under 0.25/0.1. Taking this inefficiency into account, OMC still requires 130 simulations per effective sample v 165 for SMC (ie 17/0.13 and 136/0.83).

where

rum

=

1

+

 2

erf

-1(2um

-

1).

We

put

a

positive

constraint

on

:

p()

=

U(0, 10).

We

used

2 statistics, the mean and variance of M draws from the simulator:

1 s1(x) = M xm

= f1(, u) = R(u)

f1(, u) = R(u) 

(19)

1 s2(x) = M

(xm - s1(x))2

m

= f2(, u) = 2V (u)

f2(, u) = 2V (u) 

(20)

where V (u) = m ru2m /M - R(u)2 and R(u) = m rum /M ; the exact Jacobian is therefore [R(u), 2V (u)]T . In our experiments M = 10, s(y) = [2.7, 12.8].

4.5 Lotka-Volterra

The simplest Lotka-Volterra model explains predator-prey populations over time, controlled by a set of stochastic differential equations:

dx1 dt

=

1x1

-

2x1x2

+ r1

dx2 dt

=

-2x2

- 3x1x2 + r2

(21)

where x1 and x2 are the prey and predator population sizes, respectively. Gaussian noise r  N (0, 102) is added at each full time-step. Lognormal priors are placed over . The simulator

runs for T = 50 time steps, with constant initial populations of 100 for both prey and predator.

There is therefore P = 2T outputs (prey and predator populations concatenated), which we use

as the statistics. To run a deterministic simulation, we draw ui  (u) where the dimension of

u is rust

P =

. Half 10 2

of the random variables are erf-1(2ust - 1), where s 

used for r1 and the other half for r2. In {1, 2} for the appropriate population. The

other words, Jacobian is a

100x3 matrix that can be computed using one-sided finite-differences using 3 forward simulations.

4.6 Bayesian Inference of the M/G/1 Queue Model
Bayesian inference of the M/G/1 queuing model is challenging, requiring ABC algorithms [4, 8] or sophisticated MCMC-based procedures [18]. Though simple to simulate, the output can be quite

7

Figure 4: Top: Lotka-Volterra. Bottom: M/G/1 Queue. The left plots shows the posterior mean 1 std errors of the posterior predictive distribution (sorted for M/G/1). Simulations per sample and the posterior of 1 are shown in the other plots. For L-V, at 3, the SS for OMC were 15 v 116/159 for AW/SMC, and increased at 2 to 23 v 279/371. However, the ESS/n was lower for OMC: at 3 it was 0.25 and down to 0.1 at 2, whereas ESS/n stayed around 0.9 for AW/SMC. This is again due to the optimal discrepancy for some u being greater than ; however, the samples that remain are independent samples. For M/G/1, the results are similar, but the ESS/n is lower than the number of discrepancies satisfying 1, 9% v 12%, indicating that the volume of the Jacobians is having a large effect on the variance of the weights. Future work will explore this further.

noisy. In the M/G/1 queuing model, a single server processes arriving customers, which are then
served within a random time. Customer m arrives at time wm  Exp(3) after customer m - 1, and is served in sm  U (1, 2) service time. Both wm and sm are unobserved; only the inter-departure times xm are observed. Following [18], we write the simulation algorithm in terms of arrival times vm. To simplify the updates, we keep track of the departure times dm. Initially, d0 = 0 and v0 = 0, followed by updates for m  1:

vm = vm-1 + wm

xm = sm + max(0, vm - dm-1)

dm = dm-1 + xm

(22)

After trying several optimization procedures, we found the most reliable optimizer was simply a random walk. The random sources in the problem used for Wm (there are M ) and for Um (there are M ), therefore u is dimension 2M . Typical statistics for this problem are quantiles of x and/or the minimum and maximum values; in other words, the vector x is sorted then evenly spaced values for the statistics functions f (we used 3 quantiles). The Jacobian is an M x3 matrix. In our experiments  = [1.0, 5.0, 0.2]

5 Conclusion
We have presented Optimization Monte Carlo, a likelihood-free algorithm that, by controlling the simulator randomness, transforms traditional ABC inference into a set of optimization procedures. By using OMC, scientists can focus attention on finding a useful optimization procedure for their simulator, and then use OMC in parallel to generate samples independently. We have shown that OMC can also be very efficient, though this will depend on the quality of the optimization procedure applied to each problem. In our experiments, the simulators were cheap to run, allowing Jacobian computations using finite differences. We note that for high-dimensional input spaces and expensive simulators, this may be infeasible, solutions include randomized gradient estimates [22] or automatic differentiation (AD) libraries (e.g. [14]). Future work will include incorporating AD, improving efficiency using Sobol numbers (when the size u is known), incorporating Bayesian optimization, adding partial communication between processes, and inference for expensive simulators using gradient-based optimization.
Acknowledgments
We thank the anonymous reviewers for the many useful comments that improved this manuscript. MW acknowledges support from Facebook, Google, and Yahoo.

8

References
[1] Ahn, S., Korattikara, A., Liu, N., Rajan, S., and Welling, M. (2015). Large scale distributed Bayesian matrix factorization using stochastic gradient MCMC. In KDD.
[2] Ahn, S., Shahbaba, B., and Welling, M. (2014). Distributed stochastic gradient MCMC. In Proceedings of the 31st International Conference on Machine Learning (ICML-14), pages 1044-1052.
[3] Beaumont, M. A., Cornuet, J.-M., Marin, J.-M., and Robert, C. P. (2009). Adaptive approximate Bayesian computation. Biometrika, 96(4):983-990.
[4] Blum, M. G. and Francois, O. (2010). Non-linear regression models for approximate Bayesian computation. Statistics and Computing, 20(1):63-73.
[5] Bonassi, F. V. and West, M. (2015). Sequential Monte Carlo with adaptive weights for approximate Bayesian computation. Bayesian Analysis, 10(1).
[6] Del Moral, P., Doucet, A., and Jasra, A. (2006). Sequential Monte Carlo samplers. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 68(3):411-436.
[7] Drovandi, C. C., Pettitt, A. N., and Faddy, M. J. (2011). Approximate Bayesian computation using indirect inference. Journal of the Royal Statistical Society: Series C (Applied Statistics), 60(3):317-337.
[8] Fearnhead, P. and Prangle, D. (2012). Constructing summary statistics for approximate Bayesian computation: semi-automatic approximate Bayesian computation. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 74(3):419-474.
[9] Forneron, J.-J. and Ng, S. (2015a). The ABC of simulation estimation with auxiliary statistics. arXiv preprint arXiv:1501.01265v2.
[10] Forneron, J.-J. and Ng, S. (2015b). A likelihood-free reverse sampler of the posterior distribution. arXiv preprint arXiv:1506.04017v1.
[11] Gourieroux, C., Monfort, A., and Renault, E. (1993). Indirect inference. Journal of applied econometrics, 8(S1):S85-S118.
[12] Gutmann, M. U. and Corander, J. (2015). Bayesian optimization for likelihood-free inference of simulator-based statistical models. Journal of Machine Learning Research, preprint arXiv:1501.03291. In press.
[13] Jones, D. R., Schonlau, M., and Welch, W. J. (1998). Efficient global optimization of expensive black-box functions. Journal of Global optimization, 13(4):455-492.
[14] Maclaurin, D. and Duvenaud, D. (2015). Autograd. github.com/HIPS/autograd. [15] Meeds, E., Leenders, R., and Welling, M. (2015). Hamiltonian ABC. Uncertainty in AI, 31. [16] Neal, P. (2012). Efficient likelihood-free Bayesian computation for household epidemics. Statistical
Computing, 22:1239-1256. [17] Paige, B., Wood, F., Doucet, A., and Teh, Y. W. (2014). Asynchronous anytime Sequential Monte Carlo.
In Advances in Neural Information Processing Systems, pages 3410-3418. [18] Shestopaloff, A. Y. and Neal, R. M. (2013). On Bayesian inference for the M/G/1 queue with efficient
MCMC sampling. Technical Report, Dept. of Statistics, University of Toronto. [19] Sisson, S., Fan, Y., and Tanaka, M. M. (2007). Sequential Monte Carlo without likelihoods. Proceedings
of the National Academy of Sciences, 104(6). [20] Sisson, S., Fan, Y., and Tanaka, M. M. (2009). Sequential Monte Carlo without likelihoods: Errata.
Proceedings of the National Academy of Sciences, 106(16). [21] Snoek, J., Larochelle, H., and Adams, R. P. (2012). Practical Bayesian optimization of machine learning
algorithms. Advances in Neural Information Processing Systems 25. [22] Spall, J. C. (1992). Multivariate stochastic approximation using a simultaneous perturbation gradient
approximation. Automatic Control, IEEE Transactions on, 37(3):332-341.
9

